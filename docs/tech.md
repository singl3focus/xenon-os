# Описание 

Данное руководство является небольшим пособием по разработке ОС x86, содержащее в себе, как теоритические сведения,так и практические. Если вам интересна информация по стеку технологий и теории по ним, то руководство 'technologies' идеально подойдёт. 

## Для разработчиков

- Сборка .c файлов: /
```gcc -m32 -O0 -nostdlib -nostdinc -ffreestanding -fno-builtin -fno-stack-protector -nostartfiles -nodefaultlibs -c kmain.c -o kmain.o```

- Сборка загручика: /
```nasm -f elf32 loader.s```

- Сборка ядра: /
```ld -melf_i386 -T link.ld loader.o kmain.o -o kernel.elf```

- Сборка образа ОС: /
```genisoimage -R -b boot/grub/stage2_eltorito -no-emul-boot -boot-load-size 4 -A os -input-charset utf8 -quiet -boot-info-table -o os.iso iso```

- Запуск образа через Bochs (рекомендуется 3.0 и выше): /
```bochs```

### Флаги 

GCC:
```
-m32: Генерировать 32-битный код (x86).

-nostdlib: Не использовать стандартную системную библиотеку запуска/остановки (crt0.o) и libc.

-nostdinc: Не искать заголовочные файлы (#include <...>) в стандартных системных директориях.

-fno-builtin: Отключить встроенные оптимизации компилятора для стандартных функций (если мы сами реализуем memcpy, компилятор не должен подменять её своей версией).

-fno-stack-protector: Отключить защиту стека (Canaries). В ранней ОС она не реализована и будет вызывать ошибки.

-nostartfiles: Не использовать стандартные файлы запуска (вроде crt0.o), которые вызывают main.
Мы сами инициализируем стек и вызываем kmain.

-nodefaultlibs: Явно отключить все стандартные библиотеки по умолчанию (дополнение к -nostdlib).

-Wall -Wextra -Werror: Включить все предупреждения, дополнительные предупреждения и
трактовать любое предупреждение как ошибку компиляции. Критически важно для написания надежного низкоуровневого кода.

-c: Только компилировать в объектный файл (.o), не линковать.
```

## Основная часть

### Описание работы компьютера

#### Что происходит при включении стандартного компьютера?

Обычно при нажатии кнопки включения питания от нее подается сигнал блоку питания о необходимости подачи необходимого напряжения на внутреннее и внешнее оборудование компьютера, такое как процессор, монитор, клавиатура и пр. Процессор при этом инициализирует ПЗУ-чип BIOS (базовую систему ввода/вывода) для загрузки содержащейся в нем исполняемой программы, именуемой также — BIOS.

После запуска BIOS выполняет следующие задачи:
- Тестирование оборудования при подаче питания (Power On self Test).
- Проверка частоты и доступности шин.
- Проверка системных часов и аппаратной информации в CMOS RAM.
- Проверка настроек системы, предустановок оборудования и т.д.
- Тестирование подключенного оборудования, начиная с RAM, дисководов, оптических приводов, HDD и т.д.
- В зависимости от определенной в разделе загрузочных устройств информации выполняет поиск загрузочного диска и переходит к его инициализации.

К сведению: все ЦПУ с архитектурой x86 в процессе загрузки запускаются в реальном режиме (Real Mode).

#### Что такое регистры?

Регистры в 32-разрядных системах: роль и классификация.
**Регистры** — это специализированные ячейки микропроцессора, предназначенные для временного хранения данных, адресов и управления выполнением операций. В 32-разрядных системах (x86) они играют ключевую роль в оптимизации доступа к памяти и выполнении команд. Например, при сложении чисел 2 и 3 процессор сохраняет их в регистрах общего назначения (например, EAX и EBX), выполняет операцию и помещает результат в другой регистр для вывода.

***Типы регистров в x86 (32-битная архитектура)***

1. **Регистры общего назначения (32-битные)**. Используются для арифметических операций, передачи данных и адресации. Каждый регистр имеет размер 32 бита (4 байта):
- EAX (Extended Accumulator Register) — основной регистр для арифметических операций, хранения возвращаемых значений функций.
- EBX (Extended Base Register) — часто используется как базовый указатель для адресации данных.
- ECX (Extended Counter Register) — счётчик циклов (например, в инструкциях loop).
- EDX (Extended Data Register) — хранит старшие биты результатов умножения или остаток от деления.
- ESI (Extended Source Index) — указатель на источник в операциях с данными (например, копирование строк).
- EDI (Extended Destination Index) — указатель на приёмник в операциях с данными.

2. **Сегментные регистры (16-битные)**. В 32-битном защищённом режиме сегментация используется для управления памятью и уровнями привилегий. Сегментные регистры содержат селекторы, указывающие на дескрипторы в GDT (Global Descriptor Table). Основные регистры:
- CS (Code Segment) — сегмент кода (хранит текущий сегмент исполняемых инструкций).
- DS (Data Segment) — сегмент данных (адресация переменных).
- SS (Stack Segment) — сегмент стека.
- ES, FS, GS — дополнительные сегменты данных (например, FS часто используется для доступа к TLS в современных ОС).

> Важно! В защищённом режиме адрес формируется не как сегмент * 16 + смещение, а через дескрипторы в GDT. Например, в плоской модели памяти (flat memory model) сегменты настроены на всю адресную пространство (база = 0, лимит = 4 ГБ), что упрощает адресацию.

3. **Регистры стека** (Относятся к регистрам общего назначения)
- EBP — указывает на начало текущего стекового фрейма (для доступа к аргументам и локальным переменным).
- ESP — указывает на вершину стека. Изменяется при push, pop, вызовах функций.

4. **Управляющие регистры**
- CR0 — управляет режимом работы процессора (защищённый/реальный режим, включение кэширования).
- CR3 — хранит адрес таблицы страниц (PML4 в x86-64).
- EFLAGS — флаги состояния (ZF, CF, IF и др.).


> Плоская модель памяти: сегменты DS и ES настроены на всю память, поэтому смещение вычисляется напрямую.

#### Что такое бит?

В вычислительных средах бит является наименьшей единицей данных, представляющей их в двоичном формате, где 1 = да, а 0 = нет.

Дополнительно о регистрах:

Ниже описано дальнейшее подразделение регистров:
• AX: первые 8 бит AX обозначаются как AL, последние 8 бит как AH.
• BX: первые 8 бит BX обозначаются как BL, последние 8 как как BH.
• CX: первые 8 бит CX обозначаются как CL, последние 8 бит как CH.
• DX: первые 8 бит DX обозначаются как DL, последние 8 бит как DH.

#### Как обращаться к функциям BIOS?

BIOS предоставляет ряд функций, позволяющих распределять приоритеты ЦПУ. Доступ к этим возможностям BIOS можно получить с помощью прерываний.


### Прерывания

#### Ключевые понятия

***IDT*** - это таблица дескрипторов прерываний, используемая процессором для обработки событий. Она содержит информацию о:
- Обработчиках исключений (ошибки CPU)
- Аппаратных прерываниях (IRQ - Interrupt Request)
- Программных прерываниях (системные вызовы)

Когда происходит событие (например, ошибка деления или нажатие клавиши), процессор ищет соответствующий обработчик в IDT и передает управление ему.

1. Существуют два типа обработчиков ISR и IRQ.
- ***ISR*** (Interrupt service routine) - обработчики исключений (exceptions) и программных прерываний (int X), генерируемых процессором.
    - Примеры: деление на ноль (0), двойная ошибка (8), общая защита (13).
    - Синхронны: возникают в результате выполнения конкретной инструкции.
    - Могут иметь код ошибки (error code), который процессор автоматически кладет в стек (например, для исключения 13).
    - Маскирование: Немаскируемые (NMI) или нет.
    - Номера векторов: 0–31 (зарезервированы)
- ***IRQ*** (Interrupt request) - обработчики аппартаных прерываний от устройств.
    - Примеры: IRQ0 (таймер), IRQ1 (клавиатура).
    - Асинхронны: возникают в любой момент времени, независимо от кода.
    - Требуют отправки сигнала EOI (End Of Interrupt) контроллеру прерываний (PIC/APIC).
    - Маскирование: Маскируемые (зависит от флага IF)
    - Номера векторов: 32–47 (для IRQ0–IRQ15 в x86)

2. Селектор (0x08) - указывает на дескриптор сегмента кода в GDT
3. Флаги (0x8E) - битовая маска:
    - P (Present) = 1
    - DPL (Privilege Level) = 00 (уровень ядра)
    - Type = 0xE (32-битный шлюз прерывания)
    
#### Как работает обработка прерывания
1. Процессор получает номер прерывания (N)
2. Находит N-й дескриптор в IDT
3. Проверяет права доступа
4. Сохраняет контекст
5. Переходит по адресу offset_high:offset_low
6. Выполняет обработчик (isrX или irqX)
7. Возвращает управление (команда iret)

#### Основные компоненты

1. Структуры данных
```c
struct idt_entry {
    uint16_t offset_low;   // Младшие 16 бит адреса обработчика
    uint16_t selector;     // Селектор сегмента кода в GDT
    uint8_t zero;          // Всегда 0
    uint8_t type_attr;     // Флаги типа и атрибутов
    uint16_t offset_high;  // Старшие 16 бит адреса обработчика
} __attribute__((packed));

struct idt_ptr {
    uint16_t limit;        // Размер IDT - 1
    uint32_t base;         // Базовый адрес IDT
} __attribute__((packed));
```

2. Функции

idt_set_gate() - Настраивает отдельный шлюз в IDT:

- ```num``` - номер прерывания (0-255)
- ```offset``` - адрес обработчика (функции isrX/irqX)
- ```sel``` - селектор сегмента кода (0x08 - стандартный сегмент ядра)
- ```flags``` - атрибуты шлюза (0x8E = 32-битное прерывание, уровень привилегий 0)

init_idt() - инициализирует всю IDT.

- Настраивает указатель на таблицу (idtp)
- Регистрирует обработчики исключений (0-31)
- Регистрирует обработчики IRQ (32-47)
- Загружает IDT командой lidt


#### Пример добавления обработчика
Чтобы добавить новое исключение:

1. Создайте обработчик в isr.c:
```c
void isr14(...) { ... }  // Обработчик Page Fault
```

2. Зарегистрируйте его в init_idt():
```c
idt_set_gate(14, (uint32_t)&isr14, 0x08, 0x8E);
```
